#include <iostream>
#include <vector>
#include <queue>

using namespace std;

int main() {

	int N, L, R;
	cin >> N >> L >> R;
	int count = 0;
	vector<vector<int>> _graph;

	for (int i = 0; i < N; i++) {
		vector<int> _temp;
		for (int j = 0; j < N; j++) {
			int a;
			cin >> a;
			_temp.push_back(a);
		}
		_graph.push_back(_temp);
		_temp.clear();
	}

	bool tryagain = false;
	vector < vector<pair<int, int>>> totalMove;
	for (int k = 0; k < N; k++) {
		for (int l = 0; l < N; l++) {

			vector<pair<int, int>> movesIndex;
			pair<int, int> _pair = make_pair(k, l);
			movesIndex.push_back(_pair);

			queue<pair<int, int>> _queue;
			_queue.push(_pair);
			while (!_queue.empty()) {
				int current_x = _queue.front().first;
				int current_y = _queue.front().second;
				_queue.pop();

				if (current_x - 1 >= 0) {
					int next_x = current_x - 1;
					int next_y = current_y;
					int diff = abs(_graph[current_x][current_y] - _graph[next_x][next_y]);
					bool check = false;
					if (diff >= L && diff <= R) {

						int size = movesIndex.size();
						for (int i = 0; i < size; i++) {
							int x = movesIndex[i].first;
							int y = movesIndex[i].second;

							if (next_x == x && next_y == y) {
								check = true;
								break;
								
							}
						}
						if (!check) {
							pair<int, int> _next = make_pair(next_x, next_y);
							movesIndex.push_back(_next);
							_queue.push(_next);
						}


					}
				}

				if (current_x + 1 < N) {
					int next_x = current_x + 1;
					int next_y = current_y;
					int diff = abs(_graph[current_x][current_y] - _graph[next_x][next_y]);
					bool check = false;
					if (diff >= L && diff <= R) {

						int size = movesIndex.size();
						for (int i = 0; i < size; i++) {
							int x = movesIndex[i].first;
							int y = movesIndex[i].second;

							if (next_x == x && next_y == y) {
								check = true;
								break;	
							}
						}
						if (!check) {
							pair<int, int> _next = make_pair(next_x, next_y);
							movesIndex.push_back(_next);
							_queue.push(_next);
						}

						
					}
				}

				if (current_y - 1 >= 0) {
					int next_x = current_x;
					int next_y = current_y - 1;
					int diff = abs(_graph[current_x][current_y] - _graph[next_x][next_y]);
					bool check = false;
					if (diff >= L && diff <= R) {
						int size = movesIndex.size();
						for (int i = 0; i < size; i++) {
							int x = movesIndex[i].first;
							int y = movesIndex[i].second;

							if (next_x == x && next_y == y) {
								check = true;
								break;
							}
						}
						if (!check) {
							pair<int, int> _next = make_pair(next_x, next_y);
							movesIndex.push_back(_next);
							_queue.push(_next);
						}
					}
				}

				if (current_y + 1 < N) {
					int next_x = current_x;
					int next_y = current_y + 1;
					int diff = abs(_graph[current_x][current_y] - _graph[next_x][next_y]);
					bool check = false;
					if (diff >= L && diff <= R) {
						int size = movesIndex.size();
						for (int i = 0; i < size; i++) {
							int x = movesIndex[i].first;
							int y = movesIndex[i].second;

							if (next_x == x && next_y == y) {
								check = true;
								break;
							}
						}
						if (!check) {
							pair<int, int> _next = make_pair(next_x, next_y);
							movesIndex.push_back(_next);
							_queue.push(_next);
						}
					}
				}
			}

			if (movesIndex.size() > 1) {
				totalMove.push_back(movesIndex);
				tryagain = true;
			}
			
			movesIndex.clear();
		}

		if (k == N - 1) {
			if (tryagain) {
				count++;
				tryagain = false;
				k = -1;
				int totalSize = totalMove.size();
				for (int i = 0; i < totalSize; i++) {
					int size = totalMove[i].size();
					int total = 0;
					for (int j = 0; j < size; j++) {
						int x = totalMove[i][j].first;
						int y = totalMove[i][j].second;
						total += _graph[x][y];
					}
					int value = total / size;
					for (int j = 0; j < size; j++) {
						int x = totalMove[i][j].first;
						int y = totalMove[i][j].second;
						_graph[x][y] = value;
					}

				}
			}
		}
		
	}
	cout << count << endl;
	return 0;
}

