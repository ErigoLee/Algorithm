import copy
def rotation(key):
    n = len(key)
    new_key = [[0] * n for _ in range(0, n)]

    for i in range(0,n,1):
        for j in range(0,n,1):
            new_key[j][n-1-i] = key[i][j]
    return new_key

def find(key,block,i,j,n,m):

    new_block = copy.deepcopy(block)

    for k in range(0, n, 1):
        for t in range(0, n, 1):
            new_block[k+i][t+j] = key[k][t] + block[k+i][t+j]

    for k in range(n,n+m,1):
        for t in range(n,n+m,1):
            if new_block[k][t] != 1:
                return False
    return True

def solution(key, lock):
    answer = False
    count = 0
    n = len(key)
    m = len(lock)
    block = [[0] * (2*n + m) for _ in range(0, 2*n + m)]

    for i in range(1, 2*n + m, 1):
        for j in range(1, 2*n + m, 1):
            if (i - n >= 0 and i - n < m) and (j - n >= 0 and j - n < m):
                block[i][j] = lock[i - n][j - n]
                if lock[i - n][j - n] == 0:
                    count = count + 1
            else:
                block[i][j] = 1

    a = 0
    while a < 4:

        for i in range(0,n+m,1):
            for j in range(0,n+m,1):
                answer = find(key,block,i,j,n,m)

                if answer == True:
                    return answer

        a=a+1
        key = rotation(key)

    return answer